<span data-css-15b13by="" aria-hidden="false">Get started</span>

<span data-css-15b13by="" aria-hidden="false">Log in</span>

<img src="../../pluralsight.imgix.net/author/lg/c7859b4f-a0e9-4f74-8559-62f43bdcabea.jpeg" alt="Author avatar" class="jsx-3841407315" />

Gaurav Singhal

Encoders and Decoders for Neural Machine Translation
====================================================

### Gaurav Singhal

-   Nov 19, 2020
-   11 Min read
-   2,035 Views

-   Nov 19, 2020
-   <span class="jsx-3759398792" itemprop="timeRequired">11 Min</span> read
-   2,035 Views

Introduction

8

-   <a href="#module-introduction" class="menu-link">Introduction</a>
-   <a href="#module-thepowerofsequence2sequenceseq2seqmodeling" class="menu-link">The Power of Sequence2Sequence (seq2seq) Modeling</a>
-   <a href="#module-encoderanddecoder" class="menu-link">Encoder and Decoder</a>
-   <a href="#module-importingthelibrariesandloadingthedataset" class="menu-link">Importing the Libraries and Loading the Dataset.</a>
-   <a href="#module-preprocessing" class="menu-link">Pre-processing</a>
-   <a href="#module-featureengineering" class="menu-link">Feature Engineering</a>
-   <a href="#module-conclusion" class="menu-link">Conclusion</a>
-   <a href="#top" class="menu-link">Top</a>

Introduction
------------

There are over 7,000 languages in the world. However, only 23 languages in total are most spoken around the globe, including English, Mandarin Chinese, Hindi, and Spanish. As the world is connecting faster, language translation bridges the communication gap.

![Hello in different languages](../../pluralsight2.imgix.net/guides/a486dbbd-34da-4ebc-9f05-52863b9d11ff_4.html)

[Image Source](https://en.clipdealer.com/vector/media/A:123557489)

Google Translate can translate not only text but also speech and images in real-time. You can use it on your laptop, mobile, or even smartwatch. This guide will show the technology behind this magic.

Before moving further, I would recommend reading these guides on [RNN](getting-started-with-rnn.html) and [LSTM](introduction-to-lstm-units-in-rnn.html).

To follow along with this guide, download and unzip the <span class="jsx-3120878690">`spa-eng.zip`</span> file [here](http://www.manythings.org/anki/). You will only use the *spa.txt* file for this process.

Let's get started.

The Power of Sequence2Sequence (seq2seq) Modeling
-------------------------------------------------

There are multiple tasks that can be solved by using seq2seq modeling, including text summarization, speech recognition, image and video captioning, and question answering. It can also be used in genomics for DNA sequence modeling. A seq2seq model has two parts: an encoder and a decoder. Both work separately and come together to form a huge neural network model.

This architecture has the ability to handle the input and output sequences of variable length. The below image shows the types of RNN models and their use cases.

![types of rnn model](../../pluralsight2.imgix.net/guides/706812bb-08c0-4105-a6df-27f1979f0ff7_1.html)

Encoder and Decoder
-------------------

The following sections will cover encoder-decoder in-depth.

### Encoder

The encoder is at the feeding end; it understands the sequence and reduces the dimension of the input sequence. The sequence has a fixed size known as the *context vector*. This context vector acts like input to the decoder, which generates an output sequence when reaching the end token. Hence, you can call these seq2seq models encoder-decoder models.

This architecture can handle input and output sequences of variable length.

### Decoder

If you use LSTM for the encoder, use the same for the decoder. But it's slightly more complex than the encoder network. You can say the decoder is in an "aware state." It knows what words you have generated so far and what the previous hidden state was. The first layer of the decoder is initialized by using the context vector 'C' from the encoder network to generate the output. Then a special token is applied at the start to indicate the output generation. It applies a similar token at the end. The first output word is generated by running the stacked LSTM layers. A *SoftMax* activation function applies to the last layer. Its job is to introduce non-linearity in the network. Now this word is passed through the remaining layers and the generation sequence is repeated.

Multiple factors depend upon improving the accuracy of the encoder-decoder model. The hyper-parameters such as optimizers, cross-entropy loss, learning rate, etc., play an important role in improving the model's performance.

![working of encoder and decoder](../../pluralsight2.imgix.net/guides/08e9a6f3-ce63-4f45-b162-03f34660429a_2.html)

Importing the Libraries and Loading the Dataset.
------------------------------------------------

This example will cover the simple implementation of seq2seq modeling in [Keras](https://blog.keras.io/a-ten-minute-introduction-to-sequence-to-sequence-learning-in-keras.html). I would suggest running the model on GPU. You can take advantage of [Google Colab's](https://colab.research.google.com/) free GPU feature.

Go to **Edit**, then **Notebook Settings**, make changes, and save .

![notebook settings](../../pluralsight2.imgix.net/guides/b7523400-470b-4e34-9328-2fa977c206ab_3.html)

Mount your drive first:

    1from google.colab import drive
    2drive.mount('/content/drive')

python

Copy and paste the authentication code and press enter.

Set up an environment, install the libraries, and define the parameters:

    1import tensorflow as tf
    2from tensorflow import keras
    3from keras.layers import *
    4from keras.models import *
    5from keras.utils import *
    6from keras.initializers import *
    7from keras.optimizers import * 

python

Define the parameter and set up the path for the <span class="jsx-3120878690">`spa.txt`</span> file you downloaded earlier on your drive. Define batch size, epochs to train for, LSTM latent dimensionality for the encoder, and the number of samples.

    1batch_size = 64  
    2epochs = 100  
    3latent_dim = 256  
    4num_samples = 10000  
    5# set the data_path accordingly
    6data_path = "/content/drive/My Drive/spa.txt" 

python

Change the <span class="jsx-3120878690">`data_path`</span> accordingly.

Pre-processing
--------------

You won't be required to conduct in-depth text pre-processing steps. But if you want to know more about noises associated and text pre-processing, kindly refer to this [Importance of Text Processing](importance-of-text-pre-processing.html) guide. You can use tokenization; its job is to convert the input sentence into a sequence of integers. To achieve this, pass your data by using Kerasâ€™s <span class="jsx-3120878690">`Tokenizer()`</span> class.

Next, vectorize the data. It will read each line and append a list to it. The top three lines are below .

    1input_texts = []
    2target_texts = []
    3input_characters = set()
    4target_characters = set()
    5with open(data_path, "r", encoding="utf-8") as f:
    6    lines = f.read().split("\n")

python

This example sets the parameter to 10,000 samples. The first two lines of the code below will put the English text in the <span class="jsx-3120878690">`input_text`</span> and Spanish text in <span class="jsx-3120878690">`target_text`</span>.

    1for line in lines[: min(num_samples, len(lines) - 1)]:
    2    input_text, target_text, _ = line.split("\t")
    3    ############### A ###############
    4    target_text = "\t" + target_text + "\n"
    5    input_texts.append(input_text)
    6    target_texts.append(target_text)
    7    ############### B ###############
    8    for char in input_text:
    9        if char not in input_characters:
    10            input_characters.add(char)
    11    for char in target_text:
    12        if char not in target_characters:
    13            target_characters.add(char)
    14print(input_characters)
    15print(target_characters)

python

The next step is to define the start and the end of sequence character using tab ( <span class="jsx-3120878690">`\t`</span> ) at the start of the character and <span class="jsx-3120878690">`\n`</span> at the end of the character.

Along with the English and Spanish text, you'll also want a list of their unit characters. The corresponding list output is below.

![code output](../../pluralsight2.imgix.net/guides/7638f39e-68ac-4086-a40e-4b9806b09cf8_7.html)

Define the parameters. They are important while building the model and feature engineering.

    1input_characters = sorted(list(input_characters))
    2target_characters = sorted(list(target_characters))
    3num_encoder_tokens = len(input_characters)
    4num_decoder_tokens = len(target_characters)
    5max_encoder_seq_length = max([len(txt) for txt in input_texts])
    6max_decoder_seq_length = max([len(txt) for txt in target_texts])
    7
    8print("No.of samples:", len(input_texts))
    9print("No.of unique input tokens:", num_encoder_tokens)
    10print("No.of unique output tokens:", num_decoder_tokens)
    11print("Maximum seq length for inputs:", max_encoder_seq_length)
    12print("Maximum seq length for outputs:", max_decoder_seq_length)

python

![output summary](../../pluralsight2.imgix.net/guides/c5f38ce2-60fe-45db-8dfc-7ec9dd6893d2_5.html)

Now that you have a list of the characters, perform index mapping to input and target it.

    1input_token_index = dict([(char, i) for i, char in enumerate(input_characters)])
    2target_token_index = dict([(char, i) for i, char in enumerate(target_characters)])
    3
    4print(input_token_index)
    5print(target_token_index)

python

![output of the code](../../pluralsight2.imgix.net/guides/cf301abd-d1bc-43a8-8c09-74c5d0b01e02_6.html)

Notice that each character is now associated with an integer value.

Refer the [Keras documentation](https://keras.io/examples/nlp/lstm_seq2seq/) on pre-processing for more detail.

Feature Engineering
-------------------

To generate feature vectors, on-hot encoding is used. Turn 3D numpy arrays to store one-hot encoding. To generate the feature's variables, <span class="jsx-3120878690">`encoder_input_data`</span>, <span class="jsx-3120878690">`decoder_input_data`</span>, <span class="jsx-3120878690">`decoder_target_data`</span> are used. <span class="jsx-3120878690">`encoder_input_data`</span> and <span class="jsx-3120878690">`decoder_input_data`</span> contain one-hot vectorization of English and Spanish sentences, respectively.

The first dimension, <span class="jsx-3120878690">`input_texts`</span>, states the number of sample texts (10,000 in this case). The second dimension, <span class="jsx-3120878690">`max_encoder_seq_length`</span> (English) and <span class="jsx-3120878690">`max_decoder_seq_length`</span> (Spanish), is the longest encoder/decoder sequence length within the samples. The third dimension, <span class="jsx-3120878690">`num_encoder_tokens`</span> (English) and <span class="jsx-3120878690">`num_decoder_tokens`</span> (Spanish), contains unique characters in <span class="jsx-3120878690">`input_charaters`</span> and <span class="jsx-3120878690">`output_characters`</span>.

The <span class="jsx-3120878690">`decoder_target_data`</span> is like <span class="jsx-3120878690">`decoder_input_data`</span>, the only difference is that the <span class="jsx-3120878690">`decoder_target_data`</span> is offset by one timestamp. The <span class="jsx-3120878690">`decoder_target_data[:, t, :]`</span> is the same as <span class="jsx-3120878690">`decoder_input_data[:, t + 1, :]`</span> .

Now that everything is set, build the model and put the above variables and feature vectors to their proper encoder-decoder model.

    1encoder_input_data = np.zeros(
    2  (len(input_texts), max_encoder_seq_length, num_encoder_tokens), dtype="float32"
    3)
    4
    5decoder_input_data = np.zeros(
    6  (len(input_texts), max_decoder_seq_length, num_decoder_tokens), dtype="float32"
    7)
    8
    9decoder_target_data = np.zeros(
    10  (len(input_texts), max_decoder_seq_length, num_decoder_tokens), dtype="float32"
    11)
    12
    13for i, (input_text, target_text) in enumerate(zip(input_texts, target_texts)):
    14    for t, char in enumerate(input_text):
    15        encoder_input_data[i, t, input_token_index[char]] = 1.0
    16    encoder_input_data[i, t + 1 :, input_token_index[" "]] = 1.0
    17    for t, char in enumerate(target_text):
    18        decoder_input_data[i, t, target_token_index[char]] = 1.0
    19        if t > 0:
    20            decoder_target_data[i, t - 1, target_token_index[char]] = 1.0
    21    decoder_input_data[i, t + 1 :, target_token_index[" "]] = 1.0
    22    decoder_target_data[i, t:, target_token_index[" "]] = 1.0

python

Conclusion
----------

The fundamental idea of this guide was to give a brief understanding of the seq2seq model, encoder, and decoder. [This guide](https://app.pluralsight.com/guides/nmt:-encoder-and-decoder-with-keras) will help you take this to the next level by teaching you how to build a model using LSTM RNN.

You can now choose any language of your choice. Just download the language you want to translate and define a proper path of the data. Before moving further, make sure you understand LSTM well. Feel free to ask at [Codealphabet](https://codealphabet.com/contact) if you have any queries regarding this guide.

8

[<span data-css-15b13by="" aria-hidden="false">LEARN MORE</span>](https://www.pluralsight.com/product/paths)
