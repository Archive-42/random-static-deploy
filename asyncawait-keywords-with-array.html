<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>asyncawait-keywords-with-array</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><span data-css-15b13by="" aria-hidden="false">Get started</span></p>
<p><span data-css-15b13by="" aria-hidden="false">Log in</span></p>
<p><img src="../../pluralsight.imgix.net/author/lg/b80bbd58-40e1-4db4-a8e5-12bb0fecc089.png" alt="Author avatar" class="jsx-3841407315" /></p>
<p>Zachary Bennett</p>
<h1 id="asyncawait-keywords-with-array.map-in-react">Async/Await Keywords with Array.Map in React</h1>
<h3 id="zachary-bennett">Zachary Bennett</h3>
<ul>
<li><p>Oct 10, 2020</p></li>
<li><p>5 Min read</p></li>
<li><p>9,377 Views</p></li>
<li><p>Oct 10, 2020</p></li>
<li><p><span class="jsx-3759398792" itemprop="timeRequired">5 Min</span> read</p></li>
<li><p>9,377 Views</p></li>
</ul>
<p><span class="jsx-3759398792"></span></p>
<p><span data-css-1997kh1="">Web Development</span></p>
<p><span class="jsx-3759398792"></span></p>
<p><span data-css-1997kh1="">Front End Web Development</span></p>
<p><span class="jsx-3759398792"></span></p>
<p><span data-css-1997kh1="">Client-side Frameworks</span></p>
<p><span class="jsx-3759398792"></span></p>
<p><span data-css-1997kh1="">React</span></p>
<p>Introduction</p>
<p>12</p>
<ul>
<li><a href="#module-introduction" class="menu-link">Introduction</a></li>
<li><a href="#module-asyncawaitoverview" class="menu-link">Async/Await Overview</a></li>
<li><a href="#module-usingasyncfunctionswitharraymap" class="menu-link">Using Async Functions With Array.map</a></li>
<li><a href="#module-conclusion" class="menu-link">Conclusion</a></li>
<li><a href="#top" class="menu-link">Top</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Asynchronous code is notoriously hard to understand and debug. All sorts of languages have different constructs for helping to manage this complexity. For the longest time, the only way to manage asynchronous code while using JavaScript was to use callbacks. Callbacks are functions that “call back” (execute) when an asynchronous piece of code is done running. The problem with this technique was that it led to badly nested asynchronous code that was really hard to reason about! “Callback hell” was a term coined during this time period.</p>
<p>As JavaScript progressed, promises were added to the language in order to help better reason about asynchronous code and to provide a “then-able” construct for executing long-running operations. However, promises still involved some manner of function nesting and sometimes could be harder to reason about than callbacks (depending upon the problem at hand). The async/await syntax is the solution to this problem. By providing a form of “syntactic sugar” on top of promises, the <span class="jsx-3120878690"><code>async</code></span> and <span class="jsx-3120878690"><code>await</code></span> keywords make asynchronous code look like synchronous code! Using these keywords can help dramatically simplify your code.</p>
<p>In this guide, we will specifically talk about how to use async/await syntax with the <span class="jsx-3120878690"><code>Array.map</code></span> function available to all arrays in JavaScript. You will learn how to easily execute many asynchronous pieces of code in parallel using nothing but pure JavaScript.</p>
<p>Let’s get started!</p>
<h2 id="asyncawait-overview">Async/Await Overview</h2>
<p>The async/await keywords are a wonderful mechanism for modeling asynchronous control-flow in computer programs. In JavaScript, these keywords are “syntactic sugar” on top of promises—they abstract away any calls you need to make to <span class="jsx-3120878690"><code>Promise.then</code></span>. In the following code, you can see an example of an asynchronous function within a React component:</p>
<pre><code>1...
2
3executeLongRunningTask = async () =&gt; {
4    const response = await fetch(this.taskUrl);
5    return await response.json();
6}
7
8...</code></pre>
<p>jsx</p>
<p>The code above fetches some JSON from an API. You can see that the <span class="jsx-3120878690"><code>async</code></span> keyword is used in front of the function declaration. This enables you to use the <span class="jsx-3120878690"><code>await</code></span> keyword to synchronously resolve promises within the function. When you use the <span class="jsx-3120878690"><code>await</code></span> keyword, you are guaranteed that the execution of your function will pause until <span class="jsx-3120878690"><code>await</code></span> finishes resolving your promise.</p>
<p>Now that you have seen and understand how to use async/await syntax, let’s see how you can use it with <span class="jsx-3120878690"><code>Array.map</code></span> to compose many long-running tasks.</p>
<h2 id="using-async-functions-with-array.map">Using Async Functions With Array.map</h2>
<p><span class="jsx-3120878690"><code>Array.map</code></span> is a function available on the Array prototype hierarchy. This essentially means that any JavaScript array has access to the <span class="jsx-3120878690"><code>map</code></span> function. This function receives a function as an argument and calls the given function for each item in the array, returning a value for each item that is iterated over. What’s so powerful about this is that you can use <span class="jsx-3120878690"><code>Array.map</code></span> with an async function in order to generate an array of promises! This means that you can iterate over items in an array and return a promise for each one of these items in a succinct and readable manner. In the below code, you can see the updated function that composes many long-running tasks.</p>
<pre><code>1...
2
3private taskUrls = [taskOneUrl, taskTwoUrl, taskThreeUrl];
4
5executeLongRunningTask = async (url) =&gt; {
6    return await fetch(url).then(response =&gt; response.json());
7}
8
9executeAllLongRunningTasks = async () =&gt; {
10    return await Promise.all(taskUrls.map(this.executeLongRunningtask);
11}
12
13...</code></pre>
<p>jsx</p>
<p>As you can see, in the above code the <span class="jsx-3120878690"><code>executeLongRunningTask</code></span> async function is passed into the <span class="jsx-3120878690"><code>map</code></span> call, which is mapping over a list of task URLs. For each of these URLs, a promise is returned. At the end of this iteration, an array of promises is generated. This enables the use of <span class="jsx-3120878690"><code>Promise.all</code></span>, which attempts to resolve every promise within an array in parallel and have itself resolve when all of the promises within it are complete.</p>
<p>You can now use this <span class="jsx-3120878690"><code>executeAllLongRunningTasks</code></span> function to log your new array of resolved task responses to the console like this:</p>
<pre><code>1...
2
3this.executeAllLongRunningTasks().then(console.log);
4
5...</code></pre>
<p>jsx</p>
<p>Or, if you want to use it within an async function or top-level async module:</p>
<pre><code>1...
2
3const tasks = await this.executeAllLongRunningTasks();
4console.log(tasks);
5
6...</code></pre>
<p>jsx</p>
<h2 id="conclusion">Conclusion</h2>
<p>The async/await keywords are an extremely powerful means of reasoning about asynchronous code. Using them will make your code more readable and thus more maintainable. When using async/await alongside <span class="jsx-3120878690"><code>Array.map</code></span>, you have a powerful means of executing many asynchronous functions either in sequence or in parallel.</p>
<p>You can now be confident when it comes to composing asynchronous functions using <span class="jsx-3120878690"><code>Array.map</code></span>! For more information, check out the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">documentation</a> for async/await syntax.</p>
<p>12</p>
<p><a href="https://www.pluralsight.com/product/paths"><span data-css-15b13by="" aria-hidden="false">LEARN MORE</span></a></p>
</body>
</html>
